points(costs, ycosts, type = "l", lwd = 3)
abline(v = epsilon, lty = 2, lwd = 2)
#text(x = epsilon, y = 1.5, labels = "$(1-\\epsilon)$", pos = 3)
iArrows(0.7, 1.1, 0.97, 0.9,
h.lwd=2, sh.lwd=2, sh.col="black",
curve=0.5, width=1, size=0.7)
text(0.7, 1.1, pos = 2, labels = "$E > \\epsilon$")
## third
costs = seq(0,1, 0.001)
ycosts = (costs - 0.9)^2 * 100 + 0.5
ycosts[costs < 0.9-sqrt(0.005)] = 1
epsilon = 0.95
tikz(file = "/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/2070 Research Paper/figs/e95.tex", width=5, height=3.6, symbolicColors = T, colorFileName = "")
plot(costs, ycosts, type = 'n', bty = "n", xlab = "$c_i$", ylab = "Density", xlim = c(0,1), ylim = c(0,1.5))
polygon(x = c(costs[costs < epsilon], epsilon, epsilon, 0), y = c(ycosts[costs<epsilon], (epsilon - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray11", border = FALSE, density = 30)
polygon(x = c(epsilon, costs[costs > epsilon], 1, 1, epsilon), y = c((epsilon - 0.9)^2 * 100 + 0.5, ycosts[costs>epsilon], (1 - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray22", border = FALSE, density = 30)
points(costs, ycosts, type = "l", lwd = 3)
abline(v = epsilon, lty = 2, lwd = 2)
#text(x = epsilon, y = 1.5, labels = "$(1-\\epsilon)$", pos = 3)
iArrows(0.7, 1.1, 0.97, 0.9,
h.lwd=2, sh.lwd=2, sh.col="black",
curve=0.5, width=1, size=0.7)
text(0.7, 1.1, pos = 2, labels = "$E > \\epsilon$")
endoffile <- dev.off()
require(tikz)
require(tikzDevice)
## third
costs = seq(0,1, 0.001)
ycosts = (costs - 0.9)^2 * 100 + 0.5
ycosts[costs < 0.9-sqrt(0.005)] = 1
epsilon = 0.95
tikz(file = "/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/2070 Research Paper/figs/e95.tex", width=5, height=3.6, symbolicColors = T, colorFileName = "")
plot(costs, ycosts, type = 'n', bty = "n", xlab = "$c_i$", ylab = "Density", xlim = c(0,1), ylim = c(0,1.5))
polygon(x = c(costs[costs < epsilon], epsilon, epsilon, 0), y = c(ycosts[costs<epsilon], (epsilon - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray11", border = FALSE, density = 30)
polygon(x = c(epsilon, costs[costs > epsilon], 1, 1, epsilon), y = c((epsilon - 0.9)^2 * 100 + 0.5, ycosts[costs>epsilon], (1 - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray22", border = FALSE, density = 30)
points(costs, ycosts, type = "l", lwd = 3)
abline(v = epsilon, lty = 2, lwd = 2)
#text(x = epsilon, y = 1.5, labels = "$(1-\\epsilon)$", pos = 3)
iArrows(0.7, 1.1, 0.97, 0.9,
h.lwd=2, sh.lwd=2, sh.col="black",
curve=0.5, width=1, size=0.7)
text(0.7, 1.1, pos = 2, labels = "$E > \\epsilon$")
endoffile <- dev.off()
epsilon = 0.85
plot(costs, ycosts, type = 'n', bty = "n", xlab = "$c_i$", ylab = "Density", xlim = c(0,1), ylim = c(0,1.5))
polygon(x = c(costs[costs < epsilon], epsilon, epsilon, 0), y = c(ycosts[costs<epsilon], (epsilon - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray11", border = FALSE, density = 30)
polygon(x = c(epsilon, costs[costs > epsilon], 1, 1, epsilon), y = c((epsilon - 0.9)^2 * 100 + 0.5, ycosts[costs>epsilon], (1 - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray22", border = FALSE, density = 30)
points(costs, ycosts, type = "l", lwd = 3)
abline(v = epsilon, lty = 2, lwd = 2)
#text(x = epsilon, y = 1.5, labels = "$(1-\\epsilon)$", pos = 3)
iArrows(0.7, 1.1, 0.97, 0.9,
h.lwd=2, sh.lwd=2, sh.col="black",
curve=0.5, width=1, size=0.7)
text(0.7, 1.1, pos = 2, labels = "$E > \\epsilon$")
epsilon = 0.8
plot(costs, ycosts, type = 'n', bty = "n", xlab = "$c_i$", ylab = "Density", xlim = c(0,1), ylim = c(0,1.5))
polygon(x = c(costs[costs < epsilon], epsilon, epsilon, 0), y = c(ycosts[costs<epsilon], (epsilon - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray11", border = FALSE, density = 30)
polygon(x = c(epsilon, costs[costs > epsilon], 1, 1, epsilon), y = c((epsilon - 0.9)^2 * 100 + 0.5, ycosts[costs>epsilon], (1 - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray22", border = FALSE, density = 30)
points(costs, ycosts, type = "l", lwd = 3)
abline(v = epsilon, lty = 2, lwd = 2)
#text(x = epsilon, y = 1.5, labels = "$(1-\\epsilon)$", pos = 3)
iArrows(0.7, 1.1, 0.97, 0.9,
h.lwd=2, sh.lwd=2, sh.col="black",
curve=0.5, width=1, size=0.7)
text(0.7, 1.1, pos = 2, labels = "$E > \\epsilon$")
## fourth
costs = seq(0,1, 0.001)
ycosts = (costs - 0.9)^2 * 100 + 0.5
ycosts[costs < 0.9-sqrt(0.005)] = 1
epsilon = 0.8
tikz(file = "/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/2070 Research Paper/figs/e8.tex", width=5, height=3.6, symbolicColors = T, colorFileName = "")
plot(costs, ycosts, type = 'n', bty = "n", xlab = "$c_i$", ylab = "Density", xlim = c(0,1), ylim = c(0,1.5))
polygon(x = c(costs[costs < epsilon], epsilon, epsilon, 0), y = c(ycosts[costs<epsilon], (epsilon - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray11", border = FALSE, density = 30)
polygon(x = c(epsilon, costs[costs > epsilon], 1, 1, epsilon), y = c((epsilon - 0.9)^2 * 100 + 0.5, ycosts[costs>epsilon], (1 - 0.9)^2 * 100 + 0.5, 0, 0), col = "gray22", border = FALSE, density = 30)
points(costs, ycosts, type = "l", lwd = 3)
abline(v = epsilon, lty = 2, lwd = 2)
#text(x = epsilon, y = 1.5, labels = "$(1-\\epsilon)$", pos = 3)
iArrows(0.7, 1.1, 0.97, 0.9,
h.lwd=2, sh.lwd=2, sh.col="black",
curve=0.5, width=1, size=0.7)
text(0.7, 1.1, pos = 2, labels = "$E < \\epsilon$")
endoffile <- dev.off()
resname
print(paste0("starting ", resname, ".", type))
infolder = paste0("/Volumes/GoogleDrive-106272036440850493708/.shortcut-targets-by-id/1sVj-Wi-yLgfRd7atuJRo39ftMIxtRDU0/optnets/datacoded/full_geography/", resname, "/", type)
outfolder = paste0(infolder, "/real_TJ")
dir.create(outfolder)
coords = read.csv(paste0(infolder, "/coords.csv"))
adj = read.csv(paste0(infolder, "/adj.csv"))
dist = read.csv(paste0(infolder, "/dist.csv"))
g = graph_from_adjacency_matrix(as.matrix(adj*dist), weighted = TRUE)
grid = readOGR(paste0(infolder, "/shapefile/grid.shp"))
routes = raw_routes
proj4string(stations) =  proj4string(grid)
require(rgdal)
require(rgeos)
require(sp)
require(raster)
require(RColorBrewer)
require(geosphere)
require(rjson)
require(jsonlite)
require(igraph)
source("/Users/tilmangraff/Documents/GitHub/jakarta-optimal-bus-nets/optnets-v3/better_networkplots.R")
raw_routes = read.csv("/Volumes/GoogleDrive-106272036440850493708/.shortcut-targets-by-id/1sVj-Wi-yLgfRd7atuJRo39ftMIxtRDU0/optnets/dataraw/tj_network/forbls.csv")
stations = SpatialPointsDataFrame(SpatialPoints(cbind(raw_routes$lng, raw_routes$lat)), data = data.frame("stationid" = 1:nrow(raw_routes)))
splitAt <- function(x, pos) unname(split(x, cumsum(seq_along(x) %in% pos)))
clean_up_series = function(x){
x = x[!is.na(x)]
# zeroth, cut out massive waste inbetween points
y = x[1]
for(i in 2:length(x)){
if(x[i] != x[i-1]){
y = c(y, x[i])
}
}
# first, check if there's any duplicates, if not just return y
if(sum(duplicated(y))==0){
return(y)
}else{
#if there is a duplicate, split at the duplicate and take the longest subseries
subseries = splitAt(y, which(duplicated(y)))
return(subseries[[which.max(unlist(lapply(subseries, length)))]])
}
}
resname = "5000-5000"
print(paste0("starting ", resname, ".", type))
infolder = paste0("/Volumes/GoogleDrive-106272036440850493708/.shortcut-targets-by-id/1sVj-Wi-yLgfRd7atuJRo39ftMIxtRDU0/optnets/datacoded/full_geography/", resname, "/", type)
outfolder = paste0(infolder, "/real_TJ")
coords = read.csv(paste0(infolder, "/coords.csv"))
adj = read.csv(paste0(infolder, "/adj.csv"))
dist = read.csv(paste0(infolder, "/dist.csv"))
g = graph_from_adjacency_matrix(as.matrix(adj*dist), weighted = TRUE)
grid = readOGR(paste0(infolder, "/shapefile/grid.shp"))
routes = raw_routes
proj4string(stations) =  proj4string(grid)
#### assign stations to gridcells
routes$gridid = over(stations, grid)$id
singlegridroutes = vector()
for(stub in unique(routes$stub)){
if(length(unique(routes[routes$stub == stub,"gridid"])) == 1){
singlegridroutes = c(singlegridroutes, stub)
}
}
routes = routes[!(routes$stub %in% singlegridroutes),]
bls_stops = vector(mode = "list", length(unique(routes$stub)))
bls_nbus = vector()
bls_brt = vector()
i = 1
nroutes = length(unique(routes$stub))
stub = routes$stub[1]
stationcoords = routes[routes$stub==stub, c("lng", "lat")]
stationline = (SpatialLines(list(Lines(list(Line(stationcoords)), ID = "a"))))
thisroute = routes[routes$stub == stub, "gridid"]
seriesraw = clean_up_series(thisroute)
series = seriesraw[1]
for(grid_n in 2:length(seriesraw)){
if(adj[seriesraw[grid_n], seriesraw[grid_n-1]] == 0){
start = seriesraw[grid_n-1]
end = seriesraw[grid_n]
series = c(series, as.vector(shortest_paths(g, from = start, to = end)$vpath[[1]])[-1])
}else{
series = c(series, seriesraw[grid_n])
}
}
for(grid_n in 2:length(series)){
if(adj[series[grid_n], series[grid_n-1]] == 0){
stop(paste0("WARNING! Stations ", series[grid_n], " and ", series[grid_n], " of route ", stub, " are not adjacent!!!"))
}
}
plot(stationline, lwd = 2, col = "dodgerblue2")
plot(grid[series,], add = T)
centroids = gCentroid(grid[series,], byid = T)
plot(centroids, add = T, pch = 19, cex = .6)
plot((SpatialLines(list(Lines(list(Line(centroids@coords)), ID = "a")))), add = T, lwd = 0.5)
stub
i = 19
stub = unique(routes$stub)[19]
stub
stationcoords = routes[routes$stub==stub, c("lng", "lat")]
stationline = (SpatialLines(list(Lines(list(Line(stationcoords)), ID = "a"))))
stationliner
stationline
plot(stationline)
thisroute = routes[routes$stub == stub, "gridid"]
# create a clean series
seriesraw = clean_up_series(thisroute)
series = seriesraw[1]
for(grid_n in 2:length(seriesraw)){
if(adj[seriesraw[grid_n], seriesraw[grid_n-1]] == 0){
start = seriesraw[grid_n-1]
end = seriesraw[grid_n]
series = c(series, as.vector(shortest_paths(g, from = start, to = end)$vpath[[1]])[-1])
}else{
series = c(series, seriesraw[grid_n])
}
}
for(grid_n in 2:length(series)){
if(adj[series[grid_n], series[grid_n-1]] == 0){
stop(paste0("WARNING! Stations ", series[grid_n], " and ", series[grid_n], " of route ", stub, " are not adjacent!!!"))
}
}
plot(stationline, lwd = 2, col = "dodgerblue2")
plot(grid[series,], add = T)
centroids = gCentroid(grid[series,], byid = T)
plot(centroids, add = T, pch = 19, cex = .6)
plot((SpatialLines(list(Lines(list(Line(centroids@coords)), ID = "a")))), add = T, lwd = 0.5)
unique(routes$stub)
unique(routes$stub)[19]
stub
resname = "1000-1000"
infolder = paste0("/Volumes/GoogleDrive-106272036440850493708/.shortcut-targets-by-id/1sVj-Wi-yLgfRd7atuJRo39ftMIxtRDU0/optnets/datacoded/full_geography/", resname, "/", type)
outfolder = paste0(infolder, "/real_TJ")
dir.create(outfolder)
dir.create(paste0(outfolder, "/linecharts"))
coords = read.csv(paste0(infolder, "/coords.csv"))
adj = read.csv(paste0(infolder, "/adj.csv"))
dist = read.csv(paste0(infolder, "/dist.csv"))
g = graph_from_adjacency_matrix(as.matrix(adj*dist), weighted = TRUE)
grid = readOGR(paste0(infolder, "/shapefile/grid.shp"))
routes = raw_routes
proj4string(stations) =  proj4string(grid)
#### assign stations to gridcells
routes$gridid = over(stations, grid)$id
#### drop routes that are in just a single grid cell
singlegridroutes = vector()
for(stub in unique(routes$stub)){
if(length(unique(routes[routes$stub == stub,"gridid"])) == 1){
singlegridroutes = c(singlegridroutes, stub)
}
}
routes = routes[!(routes$stub %in% singlegridroutes),]
# first, fill holes
bls_stops = vector(mode = "list", length(unique(routes$stub)))
bls_nbus = vector()
bls_brt = vector()
i = 1
nroutes = length(unique(routes$stub))
unique(routes$stub)
unique(routes$stub)[19]
stub = "13D"
stationcoords = routes[routes$stub==stub, c("lng", "lat")]
stationline = (SpatialLines(list(Lines(list(Line(stationcoords)), ID = "a"))))
thisroute = routes[routes$stub == stub, "gridid"]
# create a clean series
seriesraw = clean_up_series(thisroute)
series = seriesraw[1]
for(grid_n in 2:length(seriesraw)){
if(adj[seriesraw[grid_n], seriesraw[grid_n-1]] == 0){
start = seriesraw[grid_n-1]
end = seriesraw[grid_n]
series = c(series, as.vector(shortest_paths(g, from = start, to = end)$vpath[[1]])[-1])
}else{
series = c(series, seriesraw[grid_n])
}
}
# final check if the resulting series follows only adjacent grid cells
for(grid_n in 2:length(series)){
if(adj[series[grid_n], series[grid_n-1]] == 0){
stop(paste0("WARNING! Stations ", series[grid_n], " and ", series[grid_n], " of route ", stub, " are not adjacent!!!"))
}
}
centroids = gCentroid(grid[series,], byid = T)
centroids
plot(stationline, lwd = 2, col = "dodgerblue2")
plot(grid[series,], add = T)
plot(centroids, add = T, pch = 19, cex = .6)
plot((SpatialLines(list(Lines(list(Line(centroids@coords)), ID = "a")))), add = T, lwd = 0.5)
gCentroid()
?gCentroid
?centroid
centroid(grid[series,])
plot(centroid(grid[series,]))
plot(stationline, lwd = 2, col = "dodgerblue2")
plot(grid[series,], add = T)
plot(centroid(grid[series,]), add= T)
centroid(grid[series,])
centroid(grid[series,])
SpatialPoints(centroid(grid[series,]))
plot(SpatialPoints(centroid(grid[series,])))
centroids = SpatialPoints(centroid(grid[series,]))
plot(centroids, add = T, pch = 19, cex = .6)
plot((SpatialLines(list(Lines(list(Line(centroids@coords)), ID = "a")))), add = T, lwd = 0.5)
plot(stationline, lwd = 2, col = "dodgerblue2")
plot(grid[series,], add = T)
plot(centroids, add = T, pch = 19, cex = .6)
plot((SpatialLines(list(Lines(list(Line(centroids@coords)), ID = "a")))), add = T, lwd = 0.5)
bbox(grid[series,])
bbox(c(grid[series,], stationline))
?bbox
bbox(stationline)
bbox(stationline)[2,]
country = "Rwanda"
countryfile <- read.csv(paste("./Build/output/Network_outcomes/", country, "_outcomes.csv", sep = ""))
setwd("/Users/tilmangraff/Documents/GitHub/Thesis_Git")
countryfile <- read.csv(paste("./Build/output/Network_outcomes/", country, "_outcomes.csv", sep = ""))
head(coutrnyfile)
head(countryfile)
athome = 1 - countryfile$abroad
athome
adjraw <- read.csv(paste("./Build/temp/adj/adj_", country, ".csv", sep = ""))
dim(adjraw)
length(athome)
adj = adjraw[athome,athome]
dim(adj)
countries <- read.csv("./Build/temp/country_names.csv")
borders <- NA
for(i in 1:length(countries$x)){
country <- countries$x[i]
if(file.exists(paste("./Build/temp/adj/adj_", country, ".csv", sep = ""))){
adjraw <- read.csv(paste("./Build/temp/adj/adj_", country, ".csv", sep = ""))
countryfile <- read.csv(paste("./Build/output/Network_outcomes/", country, "_outcomes.csv", sep = ""))
athome = 1 - countryfile$abroad
adj = adjraw[athome,athome]
if(is.na(borders)){
borders <- as.data.frame(cbind(rownumber=1:length(adj), country=as.character(country), border=rowSums(adj), ID = countryfile$ID))
} else{
borders <- rbind(borders, cbind(rownumber=1:length(adj), country=as.character(country), border=rowSums(adj), ID = countryfile$ID))
}
}
}
countries
adjraw <- read.csv(paste0("./Build/temp/adj/adj_", country, ".csv"))
countryfile <- read.csv(paste0("./Build/output/Network_outcomes/", country, "_outcomes.csv"))
athome = 1 - countryfile$abroad
adj = adjraw[athome,athome]
country
country = "Rwanda"
adjraw <- read.csv(paste0("./Build/temp/adj/adj_", country, ".csv"))
countryfile <- read.csv(paste0("./Build/output/Network_outcomes/", country, "_outcomes.csv"))
athome = 1 - countryfile$abroad
adj = adjraw[athome,athome]
adj
adjraw
athome
adj = adjraw[athome==1,athome==1]
adj
length(adj)
countryfile
prodraw <- read.csv(paste0("./Build/temp/productivities/productivities_", country, ".csv"))
prodraw
prod = prodraw[athome==1,]
prod
prod$V6 == 0
plotnetworks("/Volumes/GoogleDrive-106272036440850493708/.shortcut-targets-by-id/1sVj-Wi-yLgfRd7atuJRo39ftMIxtRDU0/optnets/sa_run_outputs/20220526_115221")
install.packages("arrow")
plotnetworks = function(networkpath){
network = jsonlite::fromJSON(paste0(networkpath, "/finalnetwork.json"))
resolution = jsonlite::fromJSON(paste0(networkpath, "/params.json"))$resolution
type = jsonlite::fromJSON(paste0(networkpath, "/params.json"))$type
realtj_scenario = jsonlite::fromJSON(paste0(networkpath, "/params.json"))$realtj_scenario
# 1. import the environment
###########################
envpath = paste0("/Volumes/GoogleDrive-106272036440850493708/.shortcut-targets-by-id/1sVj-Wi-yLgfRd7atuJRo39ftMIxtRDU0/optnets/datacoded/full_geography/", resolution, "/", type)
coords = read.csv(paste0(envpath, "/coords.csv"))
if(file.exists(paste0(envpath, "/bdrive_brt.csv"))){
bdrive_brt = read.csv(paste0(envpath, "/bdrive_brt.csv"), header = FALSE)
bdrive_nonbrt = read.csv(paste0(envpath, "/bdrive_brt.csv"), header = FALSE)
}
adj = read.csv(paste0(envpath, "/adj.csv"), header = TRUE)
V = read.csv(paste0(envpath, "/V.csv"))
if(realtj_scenario){
tj_network = jsonlite::fromJSON(paste0(envpath, "/real_TJ/finalnetwork.json"))
}
pops = rowSums(V)
popweights = pops / max(pops) * 3
pdf(paste0(networkpath, "/networkplot.pdf"), width = 9, height = 9)
plot(coords$x, coords$y, asp = 1,
bty = "n", axes = FALSE, ylab = "", xlab = "", pch = 19, col = "grey",
cex = popweights)
plot(sa, add=T)
plot(dki, add=T, col = alpha("dodgerblue2", .1), border=NA)
### generate headways
headways = vector()
routelengths = vector()
if(file.exists(paste0(envpath, "/bdrive_brt.csv"))){
if(length(network[[2]])==1){
if(network[3][[1]] == 1){
routelengths = c(routelengths, routelength(network[[1]][1,],bdrive_brt)*2)
}else{
routelengths = c(routelengths, routelength(network[[1]][1,],bdrive_nonbrt)*2)
}
headways = routelengths / network[[2]]*60
}else{
for(i in 1:length(network[[1]])){
if(network[3][[1]][i] == 1){
routelengths = c(routelengths, routelength(network[[1]][i][[1]],bdrive_brt)*2)
}else{
routelengths = c(routelengths, routelength(network[[1]][i][[1]],bdrive_nonbrt)*2)
}
headways = c(headways, routelengths[i]/network[[2]][i]*60)
}
}
}else{
headways = NA
}
if(any(headways == Inf) | any(is.na(headways))){
headways = rep(1, length(network[[1]]))
}
# 2.a: plot BRT underlay
if(!realtj_scenario){
if(length(network[[2]])!=1){
brt = network[[1]][which(network[[3]]==1)]
for(brtline in brt){
for(i in 1:(length(brtline)-1)){
points(coords[c(brtline[c(i, i+1)]), "x"], coords[c(brtline[c(i, i+1)]), "y"], type = "l", col = alpha("lawngreen", .9), lwd = 10) # used to be plum1
}
}
} else{
if(network[3][[1]]==1){
for(i in 1:(length(network[[1]][1,])-1)){
points(coords[c(network[[1]][1,][c(i, i+1)]), "x"], coords[c(network[[1]][1,][c(i, i+1)]), "y"], type = "l", col = alpha("lawngreen", .9), lwd = 10) # used to be plum1
}
}
}
} else{
brt = tj_network[[1]][which(tj_network[[3]]==1)]
for(brtline in brt){
for(i in 1:(length(brtline)-1)){
points(coords[c(brtline[c(i, i+1)]), "x"], coords[c(brtline[c(i, i+1)]), "y"], type = "l", col = alpha("lawngreen", .9), lwd = 10) # used to be plum1
}
}
}
# 2. plot lines
###########################
# identify overlaps on lines
ngrams = data.frame("stations" = NA, "line" = NA, "howmany" = NA, "thisone" = NA, "color" = NA, "lwd" = NA, "horizontal" = NA, "x1" = NA, "y1" = NA, "x2" = NA, "y2" = NA, "prim_c" = NA, "sec_c" = NA, "withinline" = NA)
rowcount = 1
#colors = rainbow(length(network[[1]]))
#colors = permute(rich.colors(length(network[[1]]), palette = "temperature"))
prim_colors = c("grey", "#f44546", "#fedf17", "#04adff", "#03a8a0", "#039c4b", "#66d313",  "#ff0984", "#21409a",  "#e48873", "#f16623")
sec_colors = c("black", "white", "#039c4b", "#66d313", "#fedf17", "#ff0984", "#21409a", "#04adff", "#e48873", "#f16623", "#f44546")
colorcounter = 1
for(line in order(headways, decreasing = F)){
if(length(network[[2]])==1){
thisline = network[[1]][1,]
}else{
thisline = network[[1]][[line]]
}
withinline = 1
for(stop in 2:length(thisline)){
thestops = sort(c(thisline[stop-1], thisline[stop]))
ngrams[rowcount, "stations"] = paste(thestops, collapse = ".")
ngrams[ngrams$stations==paste(thestops, collapse = "."), "howmany"] = length(ngrams[ngrams$stations==paste(thestops, collapse = "."), "howmany"])
ngrams[rowcount, "thisone"] = length(ngrams[ngrams$stations==paste(thestops, collapse = "."), "howmany"])
ngrams[rowcount, "prim_c"] = prim_colors[colorcounter%%length(prim_colors)+1]
if(floor(colorcounter / length(sec_colors)) > 0){
ngrams[rowcount, "sec_c"] = sec_colors[floor(colorcounter / length(sec_colors))]
}
ngrams[rowcount, "withinline"] = withinline
withinline = withinline + 1
ngrams[rowcount, "horizontal"] = coords[thestops[1], "y"] == coords[thestops[2], "y"]
ngrams[rowcount, "line"] = line
ngrams[rowcount, "lwd"] = 0.3 + 0.5*(1/headways[line] / max(1/headways))
ngrams[rowcount, "x1"] = coords[thestops[1], "x"]
ngrams[rowcount, "x2"] = coords[thestops[2], "x"]
ngrams[rowcount, "y1"] = coords[thestops[1], "y"]
ngrams[rowcount, "y2"] = coords[thestops[2], "y"]
rowcount = rowcount + 1
}
colorcounter = colorcounter + 1
}
ngrams$offset = (ngrams$thisone - (ngrams$howmany+1)/2) * 0.0018
#### start plotting the ngrams
for(thisngram in 1:nrow(ngrams)){
points(
c(ngrams[thisngram, "x1"] + (1-as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"],
ngrams[thisngram, "x2"] + (1-as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"]),
c(ngrams[thisngram, "y1"] + (as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"],
ngrams[thisngram, "y2"] + (as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"]),
type="l", col=ngrams[thisngram, "prim_c"], lwd = ngrams[thisngram, "lwd"]
)
# if(ngrams[thisngram, "withinline"]>1){
#   points(
#     c(ngrams[thisngram-1, "x2"] + (1-as.numeric(ngrams[thisngram-1, "horizontal"])) * ngrams[thisngram-1, "offset"],
#       ngrams[thisngram, "x1"] + (1-as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"]),
#
#     c(ngrams[thisngram-1, "y2"] + (as.numeric(ngrams[thisngram-1, "horizontal"])) * ngrams[thisngram-1, "offset"],
#       ngrams[thisngram, "y1"] + (as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"]),
#
#     type="l", col=ngrams[thisngram, "prim_c"], lwd = ngrams[thisngram, "lwd"]
#   )
# }
if(!is.na(ngrams[thisngram,"sec_c"])){
points(
c(ngrams[thisngram, "x1"] + (1-as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"],
ngrams[thisngram, "x2"] + (1-as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"]),
c(ngrams[thisngram, "y1"] + (as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"],
ngrams[thisngram, "y2"] + (as.numeric(ngrams[thisngram, "horizontal"])) * ngrams[thisngram, "offset"]),
type="l", col=ngrams[thisngram,"sec_c"], lwd = ngrams[thisngram, "lwd"], lty=2
)
}
}
dev.off()
######################
# also plot a brief SA welfare evolution graph
if(file.exists(paste0(networkpath, "/results.csv"))){
resdf = read.csv(paste0(networkpath, "/results.csv"))
tjwelfare = jsonlite::fromJSON(paste0(networkpath, "/params.json"))$realtj_welfare
pdf(paste0(networkpath, "/welfare_evolution.pdf"), width = 8, height = 6)
plot(1:nrow(resdf), resdf$w,
bty = 'n', type = 'l', ylab = 'Aggregate Welfare', xlab = 'SA Iteration',
lwd = 2, col = 'plum3')
#points((1:nrow(resdf))[as.logical(resdf$ca)], rep(1, sum(as.logical(resdf$ca))), cex = .1)
if(!is.null(tjwelfare)){
abline(a = tjwelfare, b = 0, lty = 2, lwd = 3)
}
text(x = nrow(resdf)*0.9, y = tjwelfare, pos = 1, labels = "TJ welfare")
text(x = nrow(resdf)*0.9, y = resdf$w[round(nrow(resdf)*0.9)], pos = 1, labels = "SA welfare", col = "plum4")
dev.off()
}
}
