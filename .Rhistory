mU = nU - curr_U
if(mU>max_mU){
max_mU = mU
best_alloc = this_alloc
}
}
if(max_mU > 0){
curr_alloc = best_alloc
} else{
converged = TRUE
}
}
return(curr_alloc)
}
#print(brute_force(N))
#cdc(N)
cdc(N)
F
ps
set.seed(1234)
Nsides = 13
N = Nsides^2
r = raster(nrow = Nsides, ncol = Nsides, xmn = 0, xmx = Nsides, ymn = 0, ymx = Nsides)
ps = 1/rpareto(N, location = 0.1)
r$ps = ps
pols = rasterToPolygons(r)
distmat = gDistance(gCentroid(pols, byid = T), byid = T)
lookingat = 18
F = distmat[lookingat,]
E = 50000 # endowment, for now enough to ensure you can go everywhere
sigma = 4
U = function(alloc){
total_F = sum(F[alloc])
zeta = (E-total_F) / sum((ps[alloc])^(1-sigma))
if(zeta > 0){
demands = zeta * ps[alloc]^(-sigma)
return(sum(demands^((sigma-1)/sigma))^(sigma/(sigma-1)))
}else{
return(-Inf)
}
}
# for small Ns, can easily brute force this:
binarypermutations <- function(n, vals = c(TRUE, FALSE)){
tmp <- rep(list(vals), n)
x = do.call(expand.grid, tmp)
}
brute_force = function(N){
all_possible_allocs = binarypermutations(N)
maxU = -Inf
for(alloci in 1:nrow(all_possible_allocs)){
thisalloc = unlist(all_possible_allocs[alloci,])
thisU = U(thisalloc)
if(!is.nan(thisU)){
if(thisU > maxU){
maxU = thisU
maxalloc = thisalloc
}
}
}
return(maxalloc)
}
###############
# instead, do cdc
cdc = function(N){
curr_alloc = rep(FALSE, N)
converged = FALSE
while(!converged){
curr_U = U(curr_alloc)
max_mU = -Inf
for(i in which(!curr_alloc)){
this_alloc = curr_alloc
this_alloc[i] = TRUE
nU = U(this_alloc)
mU = nU - curr_U
if(mU>max_mU){
max_mU = mU
best_alloc = this_alloc
}
}
if(max_mU > 0){
curr_alloc = best_alloc
} else{
converged = TRUE
}
}
return(curr_alloc)
}
#print(brute_force(N))
#cdc(N)
cdc(N)
chosen = cdc(N)
r$cho = chosen
plot(r)
plot(r, "cho")
set.seed(1234)
Nsides = 13
N = Nsides^2
r = raster(nrow = Nsides, ncol = Nsides, xmn = 0, xmx = Nsides, ymn = 0, ymx = Nsides)
ps = 1/rpareto(N, location = 0.1)
r$ps = ps
pols = rasterToPolygons(r)
distmat = gDistance(gCentroid(pols, byid = T), byid = T)
lookingat = 18
F = distmat[lookingat,] / 10
E = 50000 # endowment, for now enough to ensure you can go everywhere
sigma = 4
U = function(alloc){
total_F = sum(F[alloc])
zeta = (E-total_F) / sum((ps[alloc])^(1-sigma))
if(zeta > 0){
demands = zeta * ps[alloc]^(-sigma)
return(sum(demands^((sigma-1)/sigma))^(sigma/(sigma-1)))
}else{
return(-Inf)
}
}
# for small Ns, can easily brute force this:
binarypermutations <- function(n, vals = c(TRUE, FALSE)){
tmp <- rep(list(vals), n)
x = do.call(expand.grid, tmp)
}
brute_force = function(N){
all_possible_allocs = binarypermutations(N)
maxU = -Inf
for(alloci in 1:nrow(all_possible_allocs)){
thisalloc = unlist(all_possible_allocs[alloci,])
thisU = U(thisalloc)
if(!is.nan(thisU)){
if(thisU > maxU){
maxU = thisU
maxalloc = thisalloc
}
}
}
return(maxalloc)
}
###############
# instead, do cdc
cdc = function(N){
curr_alloc = rep(FALSE, N)
converged = FALSE
while(!converged){
curr_U = U(curr_alloc)
max_mU = -Inf
for(i in which(!curr_alloc)){
this_alloc = curr_alloc
this_alloc[i] = TRUE
nU = U(this_alloc)
mU = nU - curr_U
if(mU>max_mU){
max_mU = mU
best_alloc = this_alloc
}
}
if(max_mU > 0){
curr_alloc = best_alloc
} else{
converged = TRUE
}
}
return(curr_alloc)
}
#print(brute_force(N))
#cdc(N)
chosen = cdc(N)
r$cho = chosen
plot(r, "cho")
set.seed(1234)
Nsides = 13
N = Nsides^2
r = raster(nrow = Nsides, ncol = Nsides, xmn = 0, xmx = Nsides, ymn = 0, ymx = Nsides)
ps = 1/rpareto(N, location = 0.1)
r$ps = ps
pols = rasterToPolygons(r)
distmat = gDistance(gCentroid(pols, byid = T), byid = T)
lookingat = 18
F = distmat[lookingat,] / 100
E = 50000 # endowment, for now enough to ensure you can go everywhere
sigma = 4
U = function(alloc){
total_F = sum(F[alloc])
zeta = (E-total_F) / sum((ps[alloc])^(1-sigma))
if(zeta > 0){
demands = zeta * ps[alloc]^(-sigma)
return(sum(demands^((sigma-1)/sigma))^(sigma/(sigma-1)))
}else{
return(-Inf)
}
}
# for small Ns, can easily brute force this:
binarypermutations <- function(n, vals = c(TRUE, FALSE)){
tmp <- rep(list(vals), n)
x = do.call(expand.grid, tmp)
}
brute_force = function(N){
all_possible_allocs = binarypermutations(N)
maxU = -Inf
for(alloci in 1:nrow(all_possible_allocs)){
thisalloc = unlist(all_possible_allocs[alloci,])
thisU = U(thisalloc)
if(!is.nan(thisU)){
if(thisU > maxU){
maxU = thisU
maxalloc = thisalloc
}
}
}
return(maxalloc)
}
###############
# instead, do cdc
cdc = function(N){
curr_alloc = rep(FALSE, N)
converged = FALSE
while(!converged){
curr_U = U(curr_alloc)
max_mU = -Inf
for(i in which(!curr_alloc)){
this_alloc = curr_alloc
this_alloc[i] = TRUE
nU = U(this_alloc)
mU = nU - curr_U
if(mU>max_mU){
max_mU = mU
best_alloc = this_alloc
}
}
if(max_mU > 0){
curr_alloc = best_alloc
} else{
converged = TRUE
}
}
return(curr_alloc)
}
#print(brute_force(N))
#cdc(N)
chosen = cdc(N)
r$cho = chosen
plot(r, "cho")
set.seed(1234)
Nsides = 20
N = Nsides^2
r = raster(nrow = Nsides, ncol = Nsides, xmn = 0, xmx = Nsides, ymn = 0, ymx = Nsides)
ps = 1/rpareto(N, location = 0.1)
r$ps = ps
pols = rasterToPolygons(r)
distmat = gDistance(gCentroid(pols, byid = T), byid = T)
lookingat = 18
F = distmat[lookingat,] / 100
E = 50000 # endowment, for now enough to ensure you can go everywhere
sigma = 4
U = function(alloc){
total_F = sum(F[alloc])
zeta = (E-total_F) / sum((ps[alloc])^(1-sigma))
if(zeta > 0){
demands = zeta * ps[alloc]^(-sigma)
return(sum(demands^((sigma-1)/sigma))^(sigma/(sigma-1)))
}else{
return(-Inf)
}
}
# for small Ns, can easily brute force this:
binarypermutations <- function(n, vals = c(TRUE, FALSE)){
tmp <- rep(list(vals), n)
x = do.call(expand.grid, tmp)
}
brute_force = function(N){
all_possible_allocs = binarypermutations(N)
maxU = -Inf
for(alloci in 1:nrow(all_possible_allocs)){
thisalloc = unlist(all_possible_allocs[alloci,])
thisU = U(thisalloc)
if(!is.nan(thisU)){
if(thisU > maxU){
maxU = thisU
maxalloc = thisalloc
}
}
}
return(maxalloc)
}
###############
# instead, do cdc
cdc = function(N){
curr_alloc = rep(FALSE, N)
converged = FALSE
while(!converged){
curr_U = U(curr_alloc)
max_mU = -Inf
for(i in which(!curr_alloc)){
this_alloc = curr_alloc
this_alloc[i] = TRUE
nU = U(this_alloc)
mU = nU - curr_U
if(mU>max_mU){
max_mU = mU
best_alloc = this_alloc
}
}
if(max_mU > 0){
curr_alloc = best_alloc
} else{
converged = TRUE
}
}
return(curr_alloc)
}
#print(brute_force(N))
#cdc(N)
chosen = cdc(N)
r$cho = chosen
plot(r, "cho")
set.seed(1234)
Nsides = 50
N = Nsides^2
r = raster(nrow = Nsides, ncol = Nsides, xmn = 0, xmx = Nsides, ymn = 0, ymx = Nsides)
ps = 1/rpareto(N, location = 0.1)
r$ps = ps
pols = rasterToPolygons(r)
distmat = gDistance(gCentroid(pols, byid = T), byid = T)
lookingat = 18
F = distmat[lookingat,] / 100
E = 50000 # endowment, for now enough to ensure you can go everywhere
sigma = 4
U = function(alloc){
total_F = sum(F[alloc])
zeta = (E-total_F) / sum((ps[alloc])^(1-sigma))
if(zeta > 0){
demands = zeta * ps[alloc]^(-sigma)
return(sum(demands^((sigma-1)/sigma))^(sigma/(sigma-1)))
}else{
return(-Inf)
}
}
# for small Ns, can easily brute force this:
binarypermutations <- function(n, vals = c(TRUE, FALSE)){
tmp <- rep(list(vals), n)
x = do.call(expand.grid, tmp)
}
brute_force = function(N){
all_possible_allocs = binarypermutations(N)
maxU = -Inf
for(alloci in 1:nrow(all_possible_allocs)){
thisalloc = unlist(all_possible_allocs[alloci,])
thisU = U(thisalloc)
if(!is.nan(thisU)){
if(thisU > maxU){
maxU = thisU
maxalloc = thisalloc
}
}
}
return(maxalloc)
}
###############
# instead, do cdc
cdc = function(N){
curr_alloc = rep(FALSE, N)
converged = FALSE
while(!converged){
curr_U = U(curr_alloc)
max_mU = -Inf
for(i in which(!curr_alloc)){
this_alloc = curr_alloc
this_alloc[i] = TRUE
nU = U(this_alloc)
mU = nU - curr_U
if(mU>max_mU){
max_mU = mU
best_alloc = this_alloc
}
}
if(max_mU > 0){
curr_alloc = best_alloc
} else{
converged = TRUE
}
}
return(curr_alloc)
}
#print(brute_force(N))
#cdc(N)
chosen = cdc(N)
r$cho = chosen
plot(r, "cho")
rpareto(N, location = 0.1)
1/rpareto(N, location = 0.1)
grid = readOGR("/Users/tilmangraff/Documents/GitHub/Thesis_Git/Analysis/input/grid_shapefile/grid.shp")
opt_loc = read.csv("/Users/tilmangraff/Documents/GitHub/Thesis_Git/Analysis/input/opt_loc.csv")
grid$data = merge(grid@data, opt_loc, by = "ID")
grid = readOGR("/Users/tilmangraff/Documents/GitHub/Thesis_Git/Analysis/input/grid_shapefile/grid.shp")
opt_loc = read.csv("/Users/tilmangraff/Documents/GitHub/Thesis_Git/Analysis/input/opt_loc.csv")
grid@data = merge(grid@data, opt_loc, by = "ID")
kenya = grid[grid$country =="Kenya",]
mapview(kenya)
mapview(kenya, zcol = "lighta")
mapview(kenya, zcol = "lights")
mapview(kenya, zcol = "pop")
N = length(kenya)
M
N
lookingat = 18
distmat = gDistance(gCentroid(kenya, byid=T), byid=T)
distmat
lookingat = 18
F = distmat[lookingat,] / 100
F
F = distmat[lookingat,]
F
mapview(kenya, zcol = F)
kenya$F = F
mapview(kenya, zcol = "F")
lookingat = 63
F = distmat[lookingat,]
kenya$F = F
mapview(kenya, zcol = "F")
ps = 1/kenya$pop
ps
kenya$ps = ps
mapview(kenya, "ps")
mapview(kenya, "pop")
min(kenya$pop)
max(kenya$pop)
chosen = cdc(N)
kenya = grid[grid$country =="Kenya",]
N = length(kenya)
distmat = gDistance(gCentroid(kenya, byid=T), byid=T)
lookingat = 63
F = distmat[lookingat,]
kenya$F = F
mapview(kenya, zcol = "F")
ps = 1/kenya$pop
kenya$ps = ps
chosen = cdc(N)
kenya$chosen = cdc(N)
mapview(kenya, "chosen")
lookingat = 63
F = distmat[lookingat,]
kenya$F = F
E = 100
mapview(kenya, zcol = "F")
ps = 1/kenya$pop
kenya$ps = ps
kenya$chosen = cdc(N)
mapview(kenya, "chosen")
mapview(kenya, "chosen")
mapview(kenya, "chosen")
x = mapview(kenya, "F")
x = mapview(kenya, "Fs")
x = mapview(kenya, "F")
x
#pdf("/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/ps.pdf")
mapshot(x, file = "/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/ps.pdf")
#pdf("/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/ps.pdf")
mapshot(x, file = "/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/ps.png")
x = mapview(kenya, "F")
#pdf("/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/ps.pdf")
mapshot(x, file = "/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/ps.png")
mapviewOptions(fgb = FALSE)
x = mapview(kenya, "F")
#pdf("/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/ps.pdf")
mapshot(x, file = "/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/ps.png")
mapview(kenya, "chosen")
kenya$chosen100 = cdc(N)
mapview(kenya, "chosen")
mapview(kenya, "chosen100")
E = 1000
kenya$chosen1000 = cdc(N)
mapview(kenya, "chosen1000")
E = 5000
kenya$chosen5000 = cdc(N)
mapview(kenya, "chosen5000")
E = 10000
kenya$chosen10000 = cdc(N)
mapview(kenya, "chosen10000")
for(outcome in c("F", "p", "chosen100", "chosen1000")){
x = mapview(kenya, outcome)
mapshot(x, file = paste0("/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/", outcome, ".png"))
}
for(outcome in c("F", "ps", "chosen100", "chosen1000")){
x = mapview(kenya, outcome)
mapshot(x, file = paste0("/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/", outcome, ".png"))
}
mapview(kenya, zcol = "pop")
for(outcome in c("F", "pop", "chosen100", "chosen1000")){
x = mapview(kenya, outcome)
mapshot(x, file = paste0("/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/", outcome, ".png"))
}
for(outcome in c("F", "pop", "chosen100", "chosen10000")){
x = mapview(kenya, outcome)
mapshot(x, file = paste0("/Users/tilmangraff/Dropbox (Harvard University)/Apps/Overleaf/KRA project/figs/", outcome, ".png"))
}
path = "/Users/tilmangraff/Desktop/runs"
list.files(path, full.names = T)
list.files(path, full.names = T)[1]
read.csv(list.files(path, full.names = T)[1])
df = read.csv(list.files(path, full.names = T)[1])
path = "/Users/tilmangraff/Desktop/runs"
df = read.csv(list.files(path, full.names = T)[1])
row = 1
for(i in list.files(path, full.names = T)){
df[row,] = read.csv(i)
row = row+1
}
df
plot(0,0, xlim = range(df[,4:6]))
plot(0,0, xlim = range(df[,4:6]), type = "n", ylim = c(0, 1))
plot(0,0, xlim = range(df[,4:6]), type = "n", ylim = c(0, 1), bty = "n")
polygon(density(df$param_1))
polygon(density(df$param_2))
polygon(density(df$param_3))
